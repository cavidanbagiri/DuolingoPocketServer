


-------------------------------------------------------------------- Deepseek -------------------------------------

Everthing is super. now l wanna fetch first 30 spanish words from words table and generate a sentence with yandex llm and translate the sentences to english lang.

This is my Models for doing it.

    # Define SentenceTranslation BEFORE Sentence
    class SentenceTranslation(Base):
        __tablename__ = "sentence_translations"
        id = mapped_column(Integer, primary_key=True)
        source_sentence_id = mapped_column(Integer, ForeignKey("sentences.id"))
        language_code = mapped_column(String(2), ForeignKey("languages.code"))
        translated_text = mapped_column(String(500))

        source_sentence = relationship("Sentence", back_populates="translations")

        # This is old code, and change with below new code
        # language = relationship("Language")

        language = relationship("Language", lazy="joined")


    class Sentence(Base):
        __tablename__ = "sentences"
        id = mapped_column(Integer, primary_key=True)
        text = mapped_column(String(500))  # "Hello world"
        language_code = mapped_column(String(2), ForeignKey("languages.code"))

        language = relationship("Language")
        contains_words = relationship("SentenceWord", back_populates="sentence")
        translations = relationship("SentenceTranslation", back_populates="source_sentence")


    class SentenceWord(Base):
        __tablename__ = "sentence_words"
        sentence_id = mapped_column(Integer, ForeignKey("sentences.id"), primary_key=True)
        word_id = mapped_column(Integer, ForeignKey("words.id"), primary_key=True)

        sentence = relationship("Sentence", back_populates="contains_words")
        word = relationship("Word", back_populates="in_sentences")


This is my repository class for doing it

    class GenerateSentencesSpanishAndTranslate:

        def __init__(self, db: AsyncSession):
            self.db = db
            self.api_key = os.getenv("YANDEX_LANGMODEL_API_SECRET_KEY")
            self.folder_id = os.getenv("YANDEX_FOLDER_ID")
            self.api_url = "https://llm.api.cloud.yandex.net/foundationModels/v1/completion"
            self.semaphore = asyncio.Semaphore(5)  # Limit concurrent API calls

        async def main_func(self):

            print("Generating sentences")

            return {'msg':'Generate sentence is works'}

This is my old class for fetching words from russian lang and translate to english. We can copy something from here ))

class FetchRussianWordsAndGenerateSentenceAndTranslateToEnglish:

    def __init__(self, db: AsyncSession):
        self.db = db
        self.api_key = os.getenv("YANDEX_LANGMODEL_API_SECRET_KEY")
        self.folder_id = os.getenv("YANDEX_FOLDER_ID")
        self.api_url = "https://llm.api.cloud.yandex.net/foundationModels/v1/completion"
        self.semaphore = asyncio.Semaphore(5)  # Limit concurrent API calls

    async def translate_sentence(self, text: str) -> str:
        """Translate a Russian sentence into English"""
        headers = {
            "Authorization": f"Api-Key {os.getenv('YANDEX_TRANSLATE_API_SECRET_KEY')}"
        }
        json_data = {
            "folder_id": self.folder_id,
            "texts": [text],
            "sourceLanguageCode": "ru",
            "targetLanguageCode": "en"
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(
                "https://translate.api.cloud.yandex.net/translate/v2/translate",
                headers=headers,
                json=json_data
            ) as response:
                if response.status != 200:
                    full_response = await response.text()
                    raise Exception(f"API error {response.status}: {full_response}")

                data = await response.json()
                return data['translations'][0]['text']

    async def _get_words_batch(self, offset: int, limit: int) -> List[Word]:
        """Fetch Russian words with consistent ordering"""
        try:

            result = await self.db.execute(
                select(Word)
                .where(Word.id.between(18666, 19166)) # Just call the function.
                .order_by(Word.id.asc())
                .limit(limit)
                .offset(offset)
            )

            words = result.scalars().all()
            print(f"DEBUG: Fetched {len(words)} RU words (IDs: {[w.id for w in words]})")
            return words
        except Exception as e:
            print(f"ERROR in _get_words_batch: {str(e)}")
            return []

    async def _process_word(self, word: Word) -> bool:
        """Process a single word"""
        try:
            print(f"Processing RU word ID {word.id}: {word.text}")

            # Generate sentences in Russian
            sentences = await self.generate_sentences(word.text)
            if not sentences:
                print(f"No sentences generated for {word.text}")
                return False

            # Save to DB
            await self._save_sentences(word, sentences)
            return True

        except Exception as e:
            print(f"ERROR processing {word.text}: {str(e)}")
            return False

    async def main_func(self):
        """Main execution loop"""
        try:
            print("Starting processing of Russian words...")

            # Fetch first 2 Russian words
            words = await self._get_words_batch(0, 100)
            if not words:
                print("No Russian words found!")
                return {"status": "failed", "reason": "no words found"}

            success_count = 0
            processed_ids = []

            for word in words:
                success = await self._process_word(word)
                if success:
                    success_count += 1
                    processed_ids.append(word.id)
                await asyncio.sleep(1)  # avoid rate limit

            return {
                "status": "completed",
                "total_words": len(words),
                "processed": success_count,
                "failed": len(words) - success_count,
                "processed_ids": processed_ids
            }

        except Exception as e:
            print(f"FATAL ERROR: {str(e)}")
            return {"status": "failed", "error": str(e)}

    async def _save_sentences(self, word: Word, sentences: List[str]):
        """Save RU sentences, their EN translations, and link to the word"""
        for sentence_text in sentences:
            # Save RU sentence
            sentence = Sentence(
                text=sentence_text,
                language_code="ru"
            )
            self.db.add(sentence)
            await self.db.flush()

            # Link to word
            self.db.add(SentenceWord(
                sentence_id=sentence.id,
                word_id=word.id
            ))

            # Translate to English
            try:
                en_translation = await self.translate_sentence(sentence_text)
                self.db.add(SentenceTranslation(
                    source_sentence_id=sentence.id,
                    language_code="en",
                    translated_text=en_translation
                ))
            except Exception as e:
                print(f"ERROR translating '{sentence_text}': {e}")

        await self.db.commit()

    async def generate_sentences(self, word: str) -> List[str]:
        """Generate exactly 5 Russian sentences using Yandex GPT"""
        async with aiohttp.ClientSession() as session:
            headers = {
                "Authorization": f"Api-Key {self.api_key}",
                "Content-Type": "application/json"
            }

            prompt = {
                "modelUri": f"gpt://{self.folder_id}/yandexgpt",
                "completionOptions": {
                    "stream": False,
                    "temperature": 0.6,
                    "maxTokens": "2000"
                },
                "messages": [
                    {
                        "role": "system",
                        "text": "You are a helpful assistant that generates example sentences for Russian words."
                    },
                    {
                        "role": "user",
                        "text": f"Составь ровно 5 разных предложений на русском языке, используя слово '{word}'. "
                                f"Каждое предложение должно показывать разное значение/контекст. "
                                f"Раздели предложения символом '|'. "
                                f"Верни только предложения, без лишнего текста."
                    }
                ]
            }

            try:
                async with session.post(self.api_url, json=prompt, headers=headers) as response:
                    response.raise_for_status()
                    result = await response.json()

                    sentences_text = result["result"]["alternatives"][0]["message"]["text"]
                    sentences = [s.strip() for s in sentences_text.split("|") if s.strip()]

                    if len(sentences) != 5:
                        raise ValueError(f"Expected 5 sentences, got {len(sentences)}")

                    return sentences[:5]

            except Exception as e:
                print(f"API Error for RU word {word}: {str(e)}")
                return []


